<script>
/**
 * Tennis App - Standardized UI System v2.1
 * Enhanced with League Management, Team Operations, and Visual Effects
 * Comprehensive JavaScript utilities for all tennis app components
 */

class TennisUI {
    // ==================== INITIALIZATION ====================
    
    static init() {
        console.log('🎾 Tennis UI System v2.1 Initialized');
        this.initializeFlashMessages();
        this.initializeTooltips();
        this.initializeSearchTables();
        this.initializeScheduledMatchesTable(); 
        this.loadStyles();
    }

    static initializeFlashMessages() {
        // Auto-hide flash messages after 5 seconds
        document.querySelectorAll('.alert').forEach(alert => {
            if (!alert.querySelector('.btn-close')) return;
            
            setTimeout(() => {
                if (alert.parentNode && !alert.classList.contains('fade')) {
                    alert.classList.add('fade');
                    setTimeout(() => {
                        if (alert.parentNode) alert.remove();
                    }, 150);
                }
            }, 5000);
        });
    }

    static initializeTooltips() {
        // Initialize Bootstrap tooltips if available
        if (typeof bootstrap !== 'undefined' && bootstrap.Tooltip) {
            const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
            tooltipTriggerList.map(function (tooltipTriggerEl) {
                return new bootstrap.Tooltip(tooltipTriggerEl);
            });
        }
    }

    static initializeSearchTables() {
        // Add search functionality to tables with search inputs
        document.querySelectorAll('input[data-table-search]').forEach(input => {
            const tableId = input.getAttribute('data-table-search');
            const table = document.getElementById(tableId);
            if (!table) return;

            input.addEventListener('input', (e) => {
                this.filterTable(table, e.target.value);
            });
        });
    }
    
    /**
     * Validate form by ID (convenience method)
     * @param {string} formId - The ID of the form to validate
     * @returns {boolean} - True if form is valid
     */
    static validateForm(formId) {
        const form = document.getElementById(formId);
        if (!form) {
            console.error(`Form with ID '${formId}' not found`);
            return false;
        }
        
        return TennisForms.validateForm(form);
    }

    /**
     * Show a modal by ID
     * @param {string} modalId - The ID of the modal to show
     */
    static showModal(modalId) {
        const modalElement = document.getElementById(modalId);
        if (modalElement) {
            const modal = new bootstrap.Modal(modalElement);
            modal.show();
        } else {
            console.error(`Modal with ID '${modalId}' not found`);
        }
    }
    
    /**
     * Hide a modal by ID
     * @param {string} modalId - The ID of the modal to hide
     */
    static hideModal(modalId) {
        const modalElement = document.getElementById(modalId);
        if (modalElement) {
            const modal = bootstrap.Modal.getInstance(modalElement);
            if (modal) {
                modal.hide();
            }
        } else {
            console.error(`Modal with ID '${modalId}' not found`);
        }
    }
    
    /**
     * Set modal content
     * @param {string} modalId - The ID of the modal
     * @param {string} contentId - The ID of the content element within the modal
     * @param {string} content - The HTML content to set
     */
    static setModalContent(modalId, contentId, content) {
        const contentElement = document.getElementById(contentId);
        if (contentElement) {
            contentElement.innerHTML = content;
        } else {
            console.error(`Content element with ID '${contentId}' not found in modal '${modalId}'`);
        }
    }
    
    static filterTable(table, searchTerm) {
        const rows = table.querySelectorAll('tbody tr');
        const term = searchTerm.toLowerCase();
        let visibleCount = 0;

        rows.forEach(row => {
            const text = row.textContent.toLowerCase();
            const isVisible = text.includes(term);
            row.style.display = isVisible ? '' : 'none';
            if (isVisible) visibleCount++;
        });

        // Show/hide "no results" message
        const noResults = document.getElementById('noResults');
        if (noResults) {
            noResults.style.display = visibleCount === 0 && searchTerm ? 'block' : 'none';
        }
    }

    static loadStyles() {
        // Ensure required styles are loaded
        if (!document.getElementById('tennis-ui-styles')) {
            const styles = document.createElement('style');
            styles.id = 'tennis-ui-styles';
            styles.textContent = `
                .tennis-notification {
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    z-index: 9999;
                    min-width: 350px;
                    max-width: 500px;
                    box-shadow: 0 8px 25px rgba(0,0,0,0.3);
                    animation: slideInRight 0.4s ease;
                    border-radius: 8px;
                    border: none;
                }
                
                .tennis-notification-enhanced {
                    background: rgba(255, 255, 255, 0.98) !important;
                    backdrop-filter: blur(10px);
                    border-left: 5px solid;
                    font-weight: 500;
                    padding: 1rem 1.25rem;
                }
                
                .tennis-notification-enhanced.alert-success {
                    border-left-color: #28a745;
                    background: rgba(40, 167, 69, 0.95) !important;
                    color: white;
                }
                
                .tennis-notification-enhanced.alert-danger {
                    border-left-color: #dc3545;
                    background: rgba(220, 53, 69, 0.95) !important;
                    color: white;
                }
                
                .tennis-notification-enhanced.alert-warning {
                    border-left-color: #ffc107;
                    background: rgba(255, 193, 7, 0.95) !important;
                    color: #212529;
                }
                
                .tennis-notification-enhanced.alert-info {
                    border-left-color: #007bff;
                    background: rgba(0, 123, 255, 0.95) !important;
                    color: white;
                }
                
                .tennis-notification-icon {
                    flex-shrink: 0;
                    margin-top: 2px;
                }
                
                .tennis-notification-content {
                    line-height: 1.4;
                }
                
                .tennis-notification-message {
                    font-size: 0.95rem;
                    font-weight: 500;
                }
                
                .tennis-notification:hover {
                    transform: translateX(-5px);
                    box-shadow: 0 12px 35px rgba(0,0,0,0.4);
                    transition: all 0.2s ease;
                }
                
                .fade-out {
                    animation: slideOutRight 0.3s ease forwards;
                }
                
                @keyframes slideInRight {
                    from { 
                        transform: translateX(100%); 
                        opacity: 0; 
                    }
                    to { 
                        transform: translateX(0); 
                        opacity: 1; 
                    }
                }
                
                @keyframes slideOutRight {
                    from { 
                        transform: translateX(0); 
                        opacity: 1; 
                    }
                    to { 
                        transform: translateX(100%); 
                        opacity: 0; 
                    }
                }
                
                /* Stack multiple notifications */
                .tennis-notification:nth-child(n+2) {
                    margin-top: 10px;
                }
                
                /* Enhanced close button for dark backgrounds */
                .tennis-notification .btn-close-white {
                    filter: brightness(0) invert(1);
                    opacity: 0.8;
                }
                
                .tennis-notification .btn-close-white:hover {
                    opacity: 1;
                    transform: scale(1.1);
                }
            `;
            document.head.appendChild(styles);
        }
    }


    // Add these methods to the TennisUI class in shared_scripts.html
    
    /**
     * Enhanced scheduled matches table functions with schedule button support
     */
    static initializeScheduledMatchesTable(tableSelector = '.tennis-matches-table') {
        const tables = document.querySelectorAll(tableSelector);
        tables.forEach(table => {
            // Add click handlers for action buttons
            table.addEventListener('click', (e) => {
                const target = e.target.closest('.action-btn');
                if (!target) return;
    
                const matchId = target.getAttribute('data-match-id');
                const action = target.getAttribute('data-action');
    
                switch (action) {
                    case 'view':
                        this.viewMatchDetails(matchId);
                        break;
                    case 'unschedule':
                        const description = target.getAttribute('data-description');
                        this.unscheduleMatch(matchId, description);
                        break;
                    case 'edit':
                        this.editMatchSchedule(matchId);
                        break;
                    case 'schedule':
                        this.scheduleMatch(matchId);
                        break;
                }
            });
        });
    
        // Also handle mobile card actions
        const mobileCards = document.querySelectorAll('.mobile-day-group-content');
        mobileCards.forEach(container => {
            container.addEventListener('click', (e) => {
                const target = e.target.closest('[data-action]');
                if (!target) return;
    
                const matchId = target.getAttribute('data-match-id');
                const action = target.getAttribute('data-action');
    
                switch (action) {
                    case 'unschedule':
                        e.preventDefault();
                        const description = target.getAttribute('data-description');
                        this.unscheduleMatch(matchId, description);
                        break;
                    case 'schedule':
                        e.preventDefault();
                        this.scheduleMatch(matchId);
                        break;
                }
            });
        });
    
        // Initialize schedule button helpers
        this.initializeScheduleButtonHelpers();
    }
    
    /**
     * Navigate to scheduling form for a match
     */
    static scheduleMatch(matchId) {
        // Track scheduling state for better UX
        this.trackSchedulingState(matchId, true);
        
        // Navigate to the scheduling form
        window.location.href = `/matches/${matchId}/schedule`;
    }
    
    /**
     * Enhanced unscheduleMatch method with better error handling
     */
    static async unscheduleMatch(matchId, description) {
        const confirmed = await this.showConfirmDialog(
            'Unschedule Match',
            `Are you sure you want to unschedule "${description}"?<br><small class="text-muted">This will remove all scheduling information for this match.</small>`,
            'Unschedule',
            'btn-tennis-warning'
        );
    
        if (!confirmed) return;
    
        try {
            // Show loading state
            const buttons = document.querySelectorAll(`[data-match-id="${matchId}"][data-action="unschedule"]`);
            buttons.forEach(btn => {
                btn.disabled = true;
                const originalText = btn.innerHTML;
                btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                btn.dataset.originalText = originalText;
            });
    
            const result = await this.apiCall(`/matches/${matchId}/schedule`, {
                method: 'DELETE'
            });
    
            this.showNotification(result.message || 'Match unscheduled successfully!', 'success');
            
            // Reload page after short delay
            setTimeout(() => window.location.reload(), 1000);
            
        } catch (error) {
            this.showNotification(error.message || 'Failed to unschedule match.', 'danger');
            
            // Restore button state
            const buttons = document.querySelectorAll(`[data-match-id="${matchId}"][data-action="unschedule"]`);
            buttons.forEach(btn => {
                btn.disabled = false;
                if (btn.dataset.originalText) {
                    btn.innerHTML = btn.dataset.originalText;
                    delete btn.dataset.originalText;
                }
            });
        }
    }
    
    /**
     * Navigate to reschedule form (same as schedule form, but will show current data)
     */
    static editMatchSchedule(matchId) {
        this.scheduleMatch(matchId); // Same form handles both cases
    }
    
    /**
     * Helper method for better user feedback on schedule buttons
     */
    static initializeScheduleButtonHelpers() {
        // Add tooltips to schedule buttons
        const scheduleButtons = document.querySelectorAll('.action-btn-schedule');
        scheduleButtons.forEach(button => {
            if (!button.title) {
                button.title = 'Schedule this match at optimal dates and times';
            }
            
            // Add subtle animation on hover
            button.addEventListener('mouseenter', function() {
                this.style.transform = 'translateY(-1px) scale(1.02)';
            });
            
            button.addEventListener('mouseleave', function() {
                this.style.transform = 'translateY(0) scale(1)';
            });
        });
    
        // Add progress indicators for matches that are being scheduled
        const schedulingMatches = JSON.parse(sessionStorage.getItem('schedulingMatches') || '[]');
        schedulingMatches.forEach(matchId => {
            const scheduleBtn = document.querySelector(`[data-match-id="${matchId}"].action-btn-schedule`);
            if (scheduleBtn) {
                scheduleBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                scheduleBtn.disabled = true;
                scheduleBtn.title = 'Scheduling in progress...';
            }
        });
    }
    
    /**
     * Track scheduling state across page navigation
     */
    static trackSchedulingState(matchId, isScheduling = true) {
        const schedulingMatches = JSON.parse(sessionStorage.getItem('schedulingMatches') || '[]');
        
        if (isScheduling && !schedulingMatches.includes(matchId)) {
            schedulingMatches.push(matchId);
            sessionStorage.setItem('schedulingMatches', JSON.stringify(schedulingMatches));
        } else if (!isScheduling) {
            const filtered = schedulingMatches.filter(id => id !== matchId);
            sessionStorage.setItem('schedulingMatches', JSON.stringify(filtered));
        }
    }
    
    /**
     * Clean up scheduling state indicators
     */
    static cleanupSchedulingState() {
        // Clean up any stale scheduling indicators
        const schedulingMatches = JSON.parse(sessionStorage.getItem('schedulingMatches') || '[]');
        if (schedulingMatches.length > 0) {
            // Clear after 30 seconds (in case user navigated away during scheduling)
            setTimeout(() => {
                sessionStorage.removeItem('schedulingMatches');
            }, 30000);
        }
    }
    
    /**
     * Format day name from date string
     */
    static formatDayName(dateStr) {
        if (!dateStr || dateStr === 'TBD') return 'TBD';
        
        try {
            const date = new Date(dateStr);
            return date.toLocaleDateString('en-US', { weekday: 'short' });
        } catch {
            return 'TBD';
        }
    }
    
    /**
     * Get status class for match
     */
    static getMatchStatusClass(match) {
        if (!match.scheduled_times || match.scheduled_times.length === 0) {
            return 'status-unscheduled';
        }
        
        const expectedLines = match.expected_lines || 3;
        const scheduledLines = match.scheduled_times.length;
        
        if (scheduledLines >= expectedLines) {
            return 'status-scheduled';
        } else {
            return 'status-partial';
        }
    }

    // ==================== API UTILITIES ====================

    /**
     * Make API calls with standardized error handling
     * @param {string} url - API endpoint
     * @param {Object} options - Fetch options
     * @returns {Promise} - Response data
     */
    static async apiCall(url, options = {}) {
        try {
            const defaultHeaders = {};
            
            // Only add Content-Type for JSON data
            if (options.body && typeof options.body === 'string') {
                defaultHeaders['Content-Type'] = 'application/json';
            }
            
            const response = await fetch(url, {
                headers: {
                    ...defaultHeaders,
                    ...options.headers
                },
                ...options
            });
    
            // Always try to parse JSON response (for both success and error)
            let data;
            try {
                data = await response.json();
            } catch (parseError) {
                // If JSON parsing fails, create a generic error object
                data = { 
                    error: `Server returned non-JSON response: ${response.status} ${response.statusText}` 
                };
            }
    
            // For error responses, throw an error with the server's error message
            if (!response.ok) {
                const errorMessage = data.error || data.message || `HTTP ${response.status}: ${response.statusText}`;
                console.error('API Error Response:', {
                    status: response.status,
                    statusText: response.statusText,
                    url: url,
                    errorData: data
                });
                
                // Create an error object that includes all the response data
                const error = new Error(errorMessage);
                error.status = response.status;
                error.responseData = data;
                throw error;
            }
    
            return data;
            
        } catch (error) {
            // If it's a network error or other fetch error, wrap it
            if (!error.status) {
                console.error('Network/Fetch error:', error);
                error.message = `Network error: ${error.message}`;
            }
            throw error;
        }
    }

    // ==================== BULK OPERATIONS ====================

    /**
     * Execute a bulk operation with standardized UI updates
     * @param {string} operation - Operation name (for logging)
     * @param {string} url - API endpoint
     * @param {FormData|Object} data - Data to send
     * @param {string} modalId - Modal to close on success
     * @param {Function} successCallback - Optional success callback
     */
    static async executeBulkOperation(operation, url, data, modalId, successCallback = null) {
        const submitBtn = document.querySelector(`#${modalId} .btn-tennis-warning, #${modalId} .btn-tennis-danger, #${modalId} .btn-tennis-success, #${modalId} .btn-primary`);
        
        // Set button loading state
        if (submitBtn) {
            submitBtn.disabled = true;
            submitBtn.classList.add('btn-loading');
            const originalText = submitBtn.innerHTML;
            submitBtn.setAttribute('data-original-text', originalText);
        }

        try {
            const options = {
                method: 'POST',
            };

            if (data instanceof FormData) {
                options.body = data;
            } else {
                options.body = JSON.stringify(data);
                options.headers = {
                    'Content-Type': 'application/json'
                };
            }

            const result = await this.apiCall(url, options);

            // Handle success
            this.showNotification(result.message || `${operation} completed successfully`, 'success');
            
            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById(modalId));
            if (modal) modal.hide();
            
            // Execute success callback
            if (successCallback) {
                successCallback(result);
            } else {
                // Default: reload page after short delay
                setTimeout(() => window.location.reload(), 500);
            }

        } catch (error) {
            this.showNotification(error.message || `${operation} failed`, 'danger');
            console.error(`${operation} error:`, error);
        } finally {
            // Reset button state
            if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.classList.remove('btn-loading');
                const originalText = submitBtn.getAttribute('data-original-text');
                if (originalText) {
                    submitBtn.innerHTML = originalText;
                }
            }
        }
    }

    /**
     * Create a standardized bulk operation modal
     */
    static createBulkOperationModal(operation, title, scopeOptions, alertType, alertMessage, handler, leagues = []) {
        const iconMap = {
            'auto-schedule': 'magic',
            'unschedule': 'calendar-times',
            'delete': 'trash'
        };
    
        const buttonClassMap = {
            'auto-schedule': 'btn-tennis-warning',
            'unschedule': 'btn-tennis-warning', 
            'delete': 'btn-tennis-danger'
        };
    
        const formId = `bulk${operation.charAt(0).toUpperCase() + operation.slice(1).replace('-', '')}Form`;
        const modalId = `bulk${operation.charAt(0).toUpperCase() + operation.slice(1).replace('-', '')}Modal`;
    
        const needsLeagueSelection = scopeOptions.some(option => option.value === 'league');
        
        const modalContent = `
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">
                            <i class="fas fa-${iconMap[operation]}"></i> ${title}
                        </h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <div class="modal-body">
                        <form id="${formId}" class="tennis-form">
                            <div class="mb-3">
                                <label class="form-label">
                                    <i class="fas fa-crosshairs"></i> Scope <span class="required">*</span>
                                </label>
                                <div class="form-check-container">
                                    ${scopeOptions.map((option, index) => `
                                        <div class="form-check">
                                            <input class="form-check-input" type="radio" name="scope" value="${option.value}" 
                                                   id="${operation}${option.value}" ${index === 0 ? 'checked' : ''}>
                                            <label class="form-check-label" for="${operation}${option.value}">
                                                ${option.label}
                                            </label>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                            
                            ${needsLeagueSelection ? `
                            <div class="mb-3" id="leagueSelection" style="display: none;">
                                <label for="bulkLeagueSelect" class="form-label">
                                    <i class="fas fa-trophy"></i> Select League
                                </label>
                                <select class="form-select" id="bulkLeagueSelect" name="league_id">
                                    <option value="">Choose a league...</option>
                                    ${leagues.map(league => `<option value="${league.id}">${league.name}</option>`).join('')}
                                </select>
                            </div>
                            ` : ''}
                            
                            <div class="alert alert-${alertType}">
                                <i class="fas fa-${alertType === 'danger' ? 'exclamation-triangle' : 'info-circle'}"></i>
                                ${alertMessage}
                            </div>
                        </form>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                            <i class="fas fa-times"></i> Cancel
                        </button>
                        <button type="button" class="btn ${buttonClassMap[operation]}" onclick="${handler.name}()">
                            <i class="fas fa-${iconMap[operation]}"></i> ${title}
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        const existingModal = document.getElementById(modalId);
        if (existingModal) existingModal.remove();
        
        const modalElement = document.createElement('div');
        modalElement.className = 'modal fade tennis-modal';
        modalElement.id = modalId;
        modalElement.innerHTML = modalContent;
        document.body.appendChild(modalElement);
        
        const modal = new bootstrap.Modal(modalElement);
        modal.show();
    
        if (needsLeagueSelection) {
            setTimeout(() => {
                const scopeRadios = document.querySelectorAll(`#${modalId} input[name="scope"]`);
                const leagueSelection = document.getElementById('leagueSelection');
                
                scopeRadios.forEach(radio => {
                    radio.addEventListener('change', function() {
                        if (leagueSelection) {
                            leagueSelection.style.display = this.value === 'league' ? 'block' : 'none';
                        }
                    });
                });
            }, 100);
        }
    
        modal._element.addEventListener('hidden.bs.modal', () => {
            document.getElementById(modalId).remove();
        });
    }
    
    /**
     * Add current URL filters to FormData for "selected" scope operations
     */
    static addCurrentFiltersToFormData(formData, targetScope = 'selected') {
        if (formData.get('scope') === targetScope) {
            const urlParams = new URLSearchParams(window.location.search);
            for (const [key, value] of urlParams) {
                if (!formData.has(key)) {
                    formData.append(key, value);
                }
            }
        }
    }
    


    // ==================== FORM UTILITIES ====================

    /**
     * Set form loading state
     * @param {string} formId - The ID of the form
     * @param {boolean} loading - Whether form is loading
     * @param {string} buttonSelector - CSS selector for the submit button
     */
    static setFormLoading(formId, loading, buttonSelector = 'button[type="submit"], .btn-tennis-success, .btn-tennis-primary') {
        const form = document.getElementById(formId);
        if (!form) {
            console.error(`Form with ID '${formId}' not found`);
            return;
        }

        const button = form.querySelector(buttonSelector);
        
        if (loading) {
            form.classList.add('tennis-loading');
            
            // Create loading overlay if it doesn't exist
            let overlay = form.querySelector('.tennis-loading-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.className = 'tennis-loading-overlay';
                overlay.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(255, 255, 255, 0.8);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 1000;
                    border-radius: var(--tennis-border-radius);
                `;
                overlay.innerHTML = '<div class="tennis-spinner"></div>';
                form.style.position = 'relative';
                form.appendChild(overlay);
            }
            
            // Disable and update submit button
            if (button) {
                button.disabled = true;
                if (!button.dataset.originalText) {
                    button.dataset.originalText = button.innerHTML;
                }
                button.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Processing...';
                button.classList.add('btn-loading');
            }

            // Disable all form inputs
            const inputs = form.querySelectorAll('input, select, textarea, button');
            inputs.forEach(input => {
                if (!input.hasAttribute('data-loading-disabled')) {
                    input.disabled = true;
                    input.setAttribute('data-loading-disabled', 'true');
                }
            });

        } else {
            form.classList.remove('tennis-loading');
            
            // Remove loading overlay
            const overlay = form.querySelector('.tennis-loading-overlay');
            if (overlay) {
                overlay.remove();
            }
            
            // Re-enable submit button
            if (button) {
                button.disabled = false;
                button.classList.remove('btn-loading');
                if (button.dataset.originalText) {
                    button.innerHTML = button.dataset.originalText;
                    delete button.dataset.originalText;
                }
            }

            // Re-enable form inputs
            const inputs = form.querySelectorAll('[data-loading-disabled]');
            inputs.forEach(input => {
                input.disabled = false;
                input.removeAttribute('data-loading-disabled');
            });
        }
    }

    /**
     * Serialize form data to object
     * @param {string} formId - The ID of the form
     * @returns {Object} - Form data as object
     */
    static serializeForm(formId) {
        const form = document.getElementById(formId);
        if (!form) {
            console.error(`Form with ID '${formId}' not found`);
            return {};
        }

        const formData = new FormData(form);
        const data = {};
        
        for (let [key, value] of formData.entries()) {
            if (data[key]) {
                // Handle multiple values (like checkboxes)
                if (Array.isArray(data[key])) {
                    data[key].push(value);
                } else {
                    data[key] = [data[key], value];
                }
            } else {
                data[key] = value;
            }
        }
        
        return data;
    }

    // ==================== LOADING SPINNER UTILITIES ====================

    /**
     * Show a notification message
     * @param {string} message - Message to display
     * @param {string} type - Alert type (success, danger, warning, info)
     * @param {number} duration - Auto-hide duration in milliseconds (default: 8000)
     * @param {Object} options - Additional options
     * @param {boolean} options.showRefresh - Show refresh button (default: false)
     * @param {string} options.refreshText - Text for refresh button (default: 'Refresh')
     * @param {Function} options.onRefresh - Custom refresh callback (default: page reload)
     */
    static showNotification(message, type = 'info', duration = 8000, options = {}) {
        const { 
            showRefresh = false, 
            refreshText = 'Refresh', 
            onRefresh = () => window.location.reload() 
        } = options;
    
        // Create notification element with enhanced styling
        const notification = document.createElement('div');
        notification.className = `alert alert-${type} alert-dismissible fade show tennis-notification tennis-notification-enhanced`;
        
        // Add refresh button if requested
        const refreshButton = showRefresh ? `
            <button type="button" class="btn btn-sm btn-outline-light ms-2 tennis-refresh-btn" onclick="handleNotificationRefresh(this)">
                <i class="fas fa-sync-alt"></i> ${refreshText}
            </button>
        ` : '';
        
        notification.innerHTML = `
            <div class="d-flex align-items-start">
                <div class="tennis-notification-icon me-3">
                    <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'danger' ? 'exclamation-triangle' : type === 'warning' ? 'exclamation-triangle' : 'info-circle'} fa-lg"></i>
                </div>
                <div class="tennis-notification-content flex-grow-1">
                    <div class="tennis-notification-message">${message}</div>
                </div>
                <div class="tennis-notification-actions">
                    ${refreshButton}
                    <button type="button" class="btn-close btn-close-white ms-2" data-bs-dismiss="alert" aria-label="Close"></button>
                </div>
            </div>
        `;
    
        // Store refresh callback on the notification element
        if (showRefresh) {
            notification._refreshCallback = onRefresh;
        }
    
        // Add to page
        document.body.appendChild(notification);
    
        // Add click-to-dismiss functionality
        notification.addEventListener('click', function(e) {
            if (!e.target.closest('.btn-close') && !e.target.closest('.tennis-refresh-btn')) {
                // Don't dismiss when clicking buttons
                return;
            }
        });
    
        // Auto-remove after duration (if no refresh button or user preference)
        const timeoutId = setTimeout(() => {
            if (notification.parentNode) {
                notification.classList.remove('show');
                notification.classList.add('fade-out');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.remove();
                    }
                }, 300);
            }
        }, duration);
    
        // Allow manual dismissal to cancel auto-removal
        notification.addEventListener('closed.bs.alert', () => {
            clearTimeout(timeoutId);
        });
    
        // Add hover to pause auto-dismissal
        let isPaused = false;
        notification.addEventListener('mouseenter', () => {
            isPaused = true;
            clearTimeout(timeoutId);
        });
    
        notification.addEventListener('mouseleave', () => {
            if (isPaused && !showRefresh) { // Don't auto-hide if refresh button is shown
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.classList.remove('show');
                        notification.classList.add('fade-out');
                        setTimeout(() => {
                            if (notification.parentNode) {
                                notification.remove();
                            }
                        }, 300);
                    }
                }, 2000); // 2 second delay after mouse leave
            }
        });
    }

    /**
     * Show a confirmation dialog
     * @param {string} title - Dialog title
     * @param {string} message - Dialog message
     * @param {string} confirmText - Text for confirm button
     * @param {string} confirmClass - CSS class for confirm button
     * @returns {Promise<boolean>} - True if confirmed, false if cancelled
     */
    static async showConfirmDialog(title, message, confirmText = 'Confirm', confirmClass = 'btn-primary') {
        return new Promise((resolve) => {
            // Create modal HTML
            const modalId = 'tennis-confirm-dialog';
            const existingModal = document.getElementById(modalId);
            if (existingModal) {
                existingModal.remove();
            }
    
            const modalHTML = `
                <div class="modal fade" id="${modalId}" tabindex="-1" aria-hidden="true">
                    <div class="modal-dialog">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">${title}</h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                            </div>
                            <div class="modal-body">
                                <p>${message}</p>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                                <button type="button" class="btn ${confirmClass}" id="confirm-action">${confirmText}</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
    
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            const modal = new bootstrap.Modal(document.getElementById(modalId));
            
            // Handle button clicks
            document.getElementById('confirm-action').addEventListener('click', () => {
                modal.hide();
                resolve(true);
            });
    
            modal._element.addEventListener('hidden.bs.modal', () => {
                document.getElementById(modalId).remove();
                resolve(false);
            });
    
            modal.show();
        });
    }

    /**
     * Set button loading state with text
     */
    static setButtonLoading(selector, loading, loadingText = 'Loading...') {
        const buttons = typeof selector === 'string' ? document.querySelectorAll(selector) : [selector];
        
        buttons.forEach(button => {
            if (loading) {
                if (!button.dataset.originalText) {
                    button.dataset.originalText = button.innerHTML;
                }
                button.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${loadingText}`;
                button.disabled = true;
            } else {
                button.disabled = false;
                if (button.dataset.originalText) {
                    button.innerHTML = button.dataset.originalText;
                    delete button.dataset.originalText;
                }
            }
        });
    }
    
    /**
     * Download file blob
     */
    static downloadFile(blob, filename) {
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
    }
        
}

// ==================== LEAGUE MANAGEMENT ====================

class TennisLeagues {

    /**
     * Generate matches for a league
     */
    static async generateMatches(leagueId) {
        const confirmed = await TennisUI.showConfirmDialog(
            'Generate Matches',
            `Are you sure you want to generate matches for this league? This will create match pairings for all teams in the league.`,
            'Generate Matches',
            'btn-tennis-success'
        );
    
        if (!confirmed) return;
    
        try {
            console.log(`🎲 Attempting to generate matches for league ${leagueId}`);
            
            const result = await TennisUI.apiCall(`/api/leagues/${leagueId}/generate-matches`, {
                method: 'POST'
            });
    
            console.log('✅ Generate matches successful:', result);
            TennisUI.showNotification(result.message || 'Matches generated successfully!', 'success');
            
            // Reload page to show new matches
            setTimeout(() => window.location.reload(), 1000);
            
        } catch (error) {
            console.error('❌ Generate matches error:', error);
            
            // The error.message now contains the actual JSON error message from the server
            let errorMessage = error.message || 'Failed to generate matches. Please try again.';
            
            // Log additional details if available
            if (error.responseData) {
                console.error('Server error details:', error.responseData);
                
                // If there are additional details in the response, we could use them
                if (error.responseData.teams_count !== undefined) {
                    console.log(`League has ${error.responseData.teams_count} teams`);
                }
                if (error.responseData.existing_matches_count !== undefined) {
                    console.log(`League has ${error.responseData.existing_matches_count} existing matches`);
                }
            }
            
            TennisUI.showNotification(errorMessage, 'danger', 7000); // Show for 7 seconds
        }
    }

    /**
     * Delete a single league
     */
    static async deleteLeague(leagueId, leagueName) {
        const confirmed = await TennisUI.showConfirmDialog(
            'Delete League',
            `Are you sure you want to delete league "${leagueName}"? This action cannot be undone and will also delete all associated teams and matches.`,
            'Delete League',
            'btn-tennis-danger'
        );
    
        if (!confirmed) return;
    
        try {
            console.log(`🗑️ Attempting to delete league ${leagueId}: ${leagueName}`);
            
            const result = await TennisUI.apiCall(`/api/leagues/${leagueId}`, {
                method: 'DELETE'
            });
    
            console.log('✅ Delete league successful:', result);
            TennisUI.showNotification(result.message || 'League deleted successfully!', 'success');
            
            // Reload page to reflect changes
            setTimeout(() => window.location.reload(), 1000);
            
        } catch (error) {
            console.error('❌ Delete league error:', error);
            
            let errorMessage = error.message || 'Failed to delete league. Please try again.';
            
            // Log additional details if available
            if (error.responseData) {
                console.error('Server error details:', error.responseData);
            }
            
            TennisUI.showNotification(errorMessage, 'danger', 7000);
        }
    }
    
    /**
     * Bulk delete leagues
     */
    static async bulkDeleteLeagues(leagueIds) {
        const confirmed = await TennisUI.showConfirmDialog(
            'Delete Multiple Leagues',
            `Are you sure you want to delete ${leagueIds.length} league(s)? This action cannot be undone and will also delete all associated teams and matches.`,
            `Delete ${leagueIds.length} Leagues`,
            'btn-tennis-danger'
        );

        if (!confirmed) return;

        try {
            const result = await TennisUI.apiCall('/api/leagues/bulk_delete', {
                method: 'POST',
                body: JSON.stringify({ league_ids: leagueIds })
            });

            TennisUI.showNotification(result.message || 'Leagues deleted successfully!', 'success');
            
            // Reload page
            setTimeout(() => window.location.reload(), 1000);
            
        } catch (error) {
            TennisUI.showNotification(
                error.message || 'Failed to delete leagues. Please try again.',
                'danger'
            );
        }
    }

    /**
     * Clear league filters
     */
    static clearFilters() {
        // Clear all filter inputs
        const filters = [
            '#leagueNameFilter',
            '#yearFilter', 
            '#divisionFilter',
            '#sectionFilter',
            '#ageGroupFilter'
        ];
        
        filters.forEach(selector => {
            const element = document.querySelector(selector);
            if (element) {
                element.value = '';
            }
        });
        
        // Show all rows
        document.querySelectorAll('.league-row').forEach(row => {
            row.style.display = '';
        });
        
        // Reset result count
        const totalCount = document.querySelectorAll('.league-row').length;
        document.querySelectorAll('#resultCount, #tableResultCount').forEach(element => {
            element.textContent = `${totalCount} leagues`;
        });
        
        TennisUI.showNotification('Filters cleared', 'info');
    }

    /**
     * Bulk generate matches for multiple leagues
     */
    static async bulkGenerateMatches() {
        const confirmed = await TennisUI.showConfirmDialog(
            'Bulk Generate Matches',
            'Are you sure you want to generate matches for all leagues? This will create match pairings for all teams in all leagues that don\'t already have matches.',
            'Generate All Matches',
            'btn-tennis-warning'
        );
    
        if (!confirmed) return;
    
        try {
            console.log('🎲 Attempting to bulk generate matches for all leagues');
            
            const result = await TennisUI.apiCall('/api/leagues/bulk-generate-matches', {
                method: 'POST'
            });
    
            console.log('✅ Bulk generate matches successful:', result);
            TennisUI.showNotification(result.message || 'Matches generated successfully for all leagues!', 'success');
            
            // Reload page to show new matches
            setTimeout(() => window.location.reload(), 1000);
            
        } catch (error) {
            console.error('❌ Bulk generate matches error:', error);
            
            let errorMessage = error.message || 'Failed to generate matches. Please try again.';
            
            if (error.responseData) {
                console.error('Server error details:', error.responseData);
            }
            
            TennisUI.showNotification(errorMessage, 'danger', 7000);
        }
    }
}


    
// ==================== TEAM MANAGEMENT ====================

class TennisTeams {
    /**
     * Delete a team
     */
    static async deleteTeam(teamId, teamName) {
        const confirmed = await TennisUI.showConfirmDialog(
            'Delete Team',
            `Are you sure you want to delete team "${teamName}"? This action cannot be undone and will also remove the team from all matches.`,
            'Delete Team',
            'btn-tennis-danger'
        );

        if (!confirmed) return;

        try {
            const result = await TennisUI.apiCall(`/api/teams/${teamId}`, {
                method: 'DELETE'
            });

            TennisUI.showNotification(result.message || 'Team deleted successfully!', 'success');
            
            // Reload page to reflect changes
            setTimeout(() => window.location.reload(), 1000);
            
        } catch (error) {
            TennisUI.showNotification(
                error.message || 'Failed to delete team. Please try again.',
                'danger'
            );
        }
    }

    /**
     * Bulk delete teams
     */
    static async bulkDeleteTeams(teamIds) {
        const confirmed = await TennisUI.showConfirmDialog(
            'Delete Multiple Teams',
            `Are you sure you want to delete ${teamIds.length} team(s)? This action cannot be undone and will remove the teams from all matches.`,
            `Delete ${teamIds.length} Teams`,
            'btn-tennis-danger'
        );

        if (!confirmed) return;

        try {
            const result = await TennisUI.apiCall('/api/teams/bulk_delete', {
                method: 'POST',
                body: JSON.stringify({ team_ids: teamIds })
            });

            TennisUI.showNotification(result.message || 'Teams deleted successfully!', 'success');
            
            // Reload page
            setTimeout(() => window.location.reload(), 1000);
            
        } catch (error) {
            TennisUI.showNotification(
                error.message || 'Failed to delete teams. Please try again.',
                'danger'
            );
        }
    }
}

// ==================== MATCH MANAGEMENT ====================

class TennisMatches {
    /**
     * Delete a match
     */
    static async deleteMatch(matchId, matchDescription) {
        const confirmed = await TennisUI.showConfirmDialog(
            'Delete Match',
            `Are you sure you want to delete this match "${matchDescription}"? This action cannot be undone.`,
            'Delete Match',
            'btn-tennis-danger'
        );

        if (!confirmed) return;

        try {
            const result = await TennisUI.apiCall(`/api/matches/${matchId}`, {
                method: 'DELETE'
            });

            TennisUI.showNotification(result.message || 'Match deleted successfully!', 'success');
            
            // Reload page to reflect changes
            setTimeout(() => window.location.reload(), 1000);
            
        } catch (error) {
            TennisUI.showNotification(
                error.message || 'Failed to delete match. Please try again.',
                'danger'
            );
        }
    }

    /**
     * Schedule a match
     */
    static async scheduleMatch(matchId, facilityId, date, time) {
        try {
            const result = await TennisUI.apiCall(`/api/matches/${matchId}/schedule`, {
                method: 'POST',
                body: JSON.stringify({
                    facility_id: facilityId,
                    date: date,
                    time: time
                })
            });

            TennisUI.showNotification(result.message || 'Match scheduled successfully!', 'success');
            
            // Reload page to show updated schedule
            setTimeout(() => window.location.reload(), 1000);
            
        } catch (error) {
            TennisUI.showNotification(
                error.message || 'Failed to schedule match. Please try again.',
                'danger'
            );
        }
    }

    /**
     * Bulk delete matches
     */
    static async bulkDeleteMatches(matchIds) {
        const confirmed = await TennisUI.showConfirmDialog(
            'Delete Multiple Matches',
            `Are you sure you want to delete ${matchIds.length} match(es)? This action cannot be undone.`,
            `Delete ${matchIds.length} Matches`,
            'btn-tennis-danger'
        );

        if (!confirmed) return;

        try {
            const result = await TennisUI.apiCall('/api/matches/bulk_delete', {
                method: 'POST',
                body: JSON.stringify({ match_ids: matchIds })
            });

            TennisUI.showNotification(result.message || 'Matches deleted successfully!', 'success');
            
            // Reload page
            setTimeout(() => window.location.reload(), 1000);
            
        } catch (error) {
            TennisUI.showNotification(
                error.message || 'Failed to delete matches. Please try again.',
                'danger'
            );
        }
    }
}

// ==================== FACILITY MANAGEMENT ====================

class TennisFacilities {
    /**
     * Delete a facility
     */
    static async deleteFacility(facilityId, facilityName) {
        const confirmed = await TennisUI.showConfirmDialog(
            'Delete Facility',
            `Are you sure you want to delete facility "${facilityName}"? This action cannot be undone and may affect teams and matches using this facility.`,
            'Delete Facility',
            'btn-tennis-danger'
        );

        if (!confirmed) return;

        try {
            const result = await TennisUI.apiCall(`/api/facilities/${facilityId}`, {
                method: 'DELETE'
            });

            TennisUI.showNotification(result.message || 'Facility deleted successfully!', 'success');
            
            // Reload page to reflect changes
            setTimeout(() => window.location.reload(), 1000);
            
        } catch (error) {
            TennisUI.showNotification(
                error.message || 'Failed to delete facility. Please try again.',
                'danger'
            );
        }
    }
}

// ==================== FORM ENHANCEMENTS ====================

class TennisForms {
    /**
     * Initialize form validation and enhancement
     */
    static initializeFormValidation() {
        document.querySelectorAll('.tennis-form').forEach(form => {
            form.addEventListener('submit', this.handleFormSubmit.bind(this));
            
            // Add real-time validation
            form.querySelectorAll('input, select, textarea').forEach(field => {
                field.addEventListener('blur', () => this.validateField(field));
                field.addEventListener('input', () => this.clearFieldError(field));
            });
        });
    }

    static handleFormSubmit(event) {
        const form = event.target;
        const isValid = this.validateForm(form);
        
        if (!isValid) {
            event.preventDefault();
            TennisUI.showNotification('Please correct the errors in the form', 'warning');
        }
    }

    static validateForm(form) {
        let isValid = true;
        
        form.querySelectorAll('[required]').forEach(field => {
            if (!this.validateField(field)) {
                isValid = false;
            }
        });
      
        return isValid;
    }

    static validateField(field) {
        const value = field.value.trim();
        const isRequired = field.hasAttribute('required');
        const fieldType = field.type;
        
        // Clear previous errors
        this.clearFieldError(field);
        
        // Check required fields
        if (isRequired && !value) {
            this.showFieldError(field, 'This field is required');
            return false;
        }
        
        // Type-specific validation
        if (value) {
            switch (fieldType) {
                case 'email':
                    if (!this.isValidEmail(value)) {
                        this.showFieldError(field, 'Please enter a valid email address');
                        return false;
                    }
                    break;
                case 'number':
                    const min = field.getAttribute('min');
                    const max = field.getAttribute('max');
                    const numValue = parseFloat(value);
                    
                    if (isNaN(numValue)) {
                        this.showFieldError(field, 'Please enter a valid number');
                        return false;
                    }
                    
                    if (min !== null && numValue < parseFloat(min)) {
                        this.showFieldError(field, `Value must be at least ${min}`);
                        return false;
                    }
                    
                    if (max !== null && numValue > parseFloat(max)) {
                        this.showFieldError(field, `Value must be no more than ${max}`);
                        return false;
                    }
                    break;
            }
        }
        
        return true;
    }

    static showFieldError(field, message) {
        field.classList.add('is-invalid');
        
        let feedback = field.parentNode.querySelector('.invalid-feedback');
        if (!feedback) {
            feedback = document.createElement('div');
            feedback.className = 'invalid-feedback';
            field.parentNode.appendChild(feedback);
        }
        
        feedback.textContent = message;
    }

    static clearFieldError(field) {
        field.classList.remove('is-invalid');
        const feedback = field.parentNode.querySelector('.invalid-feedback');
        if (feedback) {
            feedback.remove();
        }
    }

    static isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }
}

// ==================== DROPDOWN ENHANCEMENTS ====================

class TennisDropdowns {
    static init() {
        this.initializeCascadingDropdowns();
        this.initializeSearchableDropdowns();
        console.log('✅ Dropdown Management - Initialized');
    }
    
    static initializeCascadingDropdowns() {
        // Section -> Region cascading
        const sectionSelect = document.getElementById('section');
        const regionSelect = document.getElementById('region');
        
        if (sectionSelect && regionSelect) {
            sectionSelect.addEventListener('change', () => {
                this.updateRegionOptions(sectionSelect.value, regionSelect);
            });
        }
    }
    
    static updateRegionOptions(section, regionSelect) {
        // This would be populated with actual region data
        const regionsBySection = {
            'Southwest': ['Northern New Mexico', 'Southern New Mexico', 'Arizona', 'Colorado'],
            'Texas': ['North Texas', 'South Texas', 'East Texas', 'West Texas'],
            'Southern': ['Georgia', 'Alabama', 'Florida', 'South Carolina']
        };
        
        regionSelect.innerHTML = '<option value="">Select a region...</option>';
        
        if (regionsBySection[section]) {
            regionsBySection[section].forEach(region => {
                const option = document.createElement('option');
                option.value = region;
                option.textContent = region;
                regionSelect.appendChild(option);
            });
        }
    }
    
    static initializeSearchableDropdowns() {
        // Add search functionality to large dropdowns
        document.querySelectorAll('select[data-searchable]').forEach(select => {
            this.makeDropdownSearchable(select);
        });
    }
    
    static makeDropdownSearchable(select) {
        // This would implement a searchable dropdown functionality
        // For now, just add basic filtering
        const wrapper = document.createElement('div');
        wrapper.className = 'searchable-dropdown';
        select.parentNode.insertBefore(wrapper, select);
        wrapper.appendChild(select);
        
        const search = document.createElement('input');
        search.type = 'text';
        search.className = 'form-control mb-2';
        search.placeholder = 'Search options...';
        wrapper.insertBefore(search, select);
        
        search.addEventListener('input', () => {
            const searchTerm = search.value.toLowerCase();
            Array.from(select.options).forEach(option => {
                option.style.display = option.text.toLowerCase().includes(searchTerm) ? '' : 'none';
            });
        });
    }
}

// ==================== BADGE MANAGEMENT ====================

class TennisBadges {
    static init() {
        this.initializeBadgeAnimations();
        this.initializeStatusBadges();
        console.log('✅ Badge Management - Initialized');
    }
    
    static initializeBadgeAnimations() {
        document.querySelectorAll('.badge, .tennis-badge-info, .tennis-badge-warning, .tennis-badge-success').forEach(badge => {
            badge.addEventListener('mouseenter', function() {
                this.style.transform = 'scale(1.05)';
                this.style.transition = 'transform 0.15s ease';
            });
            
            badge.addEventListener('mouseleave', function() {
                this.style.transform = 'scale(1)';
            });
        });
    }
    
    static initializeStatusBadges() {
        // Update badge colors based on status
        document.querySelectorAll('[data-status]').forEach(element => {
            const status = element.dataset.status;
            this.updateStatusBadge(element, status);
        });
    }
    
    static updateStatusBadge(element, status) {
        element.classList.remove('bg-success', 'bg-warning', 'bg-danger', 'bg-info', 'bg-secondary');
        
        switch(status.toLowerCase()) {
            case 'active':
            case 'scheduled':
            case 'completed':
                element.classList.add('bg-success');
                break;
            case 'pending':
            case 'unscheduled':
                element.classList.add('bg-warning');
                break;
            case 'cancelled':
            case 'inactive':
                element.classList.add('bg-danger');
                break;
            case 'in-progress':
                element.classList.add('bg-info');
                break;
            default:
                element.classList.add('bg-secondary');
        }
    }
}

// ==================== CARD MANAGEMENT ====================

class TennisCards {
    static init() {
        this.initializeCardAnimations();
        this.initializeStatCards();
        console.log('✅ Card Management - Initialized');
    }
    
    static initializeCardAnimations() {
        // Enhanced hover effects for tennis cards
        document.querySelectorAll('.tennis-card').forEach(card => {
            card.addEventListener('mouseenter', function() {
                this.style.transform = 'translateY(-2px)';
                this.style.boxShadow = '0 8px 25px rgba(0,0,0,0.12)';
                this.style.transition = 'all 0.2s ease';
            });
            
            card.addEventListener('mouseleave', function() {
                this.style.transform = 'translateY(0)';
                this.style.boxShadow = '';
            });
        });
        
        // Special handling for league detail cards
        document.querySelectorAll('.league-detail-card').forEach(card => {
            card.addEventListener('mouseenter', function() {
                this.style.transform = 'translateY(-3px)';
                this.style.boxShadow = '0 8px 25px rgba(0,0,0,0.12)';
            });
            
            card.addEventListener('mouseleave', function() {
                this.style.transform = 'translateY(0)';
                this.style.boxShadow = '';
            });
        });
    }
    
    static initializeStatCards() {
        // Animate stat card numbers on scroll
        const statCards = document.querySelectorAll('.stat-card h4');
        
        if ('IntersectionObserver' in window) {
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        this.animateNumber(entry.target);
                        observer.unobserve(entry.target);
                    }
                });
            });
            
            statCards.forEach(card => observer.observe(card));
        }
    }
    
    static animateNumber(element) {
        const finalNumber = parseInt(element.textContent);
        if (isNaN(finalNumber)) return;
        
        let currentNumber = 0;
        const increment = Math.ceil(finalNumber / 20);
        const timer = setInterval(() => {
            currentNumber += increment;
            if (currentNumber >= finalNumber) {
                currentNumber = finalNumber;
                clearInterval(timer);
            }
            element.textContent = currentNumber;
        }, 50);
    }
}


// ==================== GENERALIZED IMPORT/EXPORT MANAGEMENT ====================


// ==================== COMPLETE TENNIS IMPORT/EXPORT CLASS ====================

class TennisImportExport {
    static selectedFile = null;
    static currentModal = null;
    static fileAnalysis = null;

    /**
     * Show universal import/export modal
     */
    static showModal(title = 'Import/Export Data') {
        // Remove existing modal if present
        this.removeExistingModal();
        
        // Create and show modal
        const modalHtml = this.createUniversalModalHtml(title);
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        
        // Initialize modal
        this.currentModal = new bootstrap.Modal(document.getElementById('tennisUniversalModal'));
        this.currentModal.show();
        
        // Setup event handlers after modal is in DOM
        setTimeout(() => this.setupEventHandlers(), 100);
        
        // Load current component info
        this.loadComponentInfo();
        
        // Clean up on close
        this.currentModal._element.addEventListener('hidden.bs.modal', () => {
            this.removeExistingModal();
        });
    }

    /**
     * Create universal modal HTML for multi-component import/export
     */
    static createUniversalModalHtml(title) {
        return `
        <div class="modal fade tennis-modal" id="tennisUniversalModal" tabindex="-1" aria-hidden="true">
            <div class="modal-dialog modal-xl">
                <div class="modal-content">
                    <div class="modal-header tennis-modal-header">
                        <h5 class="modal-title">
                            <i class="fas fa-exchange-alt text-tennis-primary"></i>
                            ${title}
                        </h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <!-- Component Status Section -->
                        <div class="row mb-4">
                            <div class="col-12">
                                <h6><i class="fas fa-database text-info"></i> Current Database</h6>
                                <div id="componentStatus" class="d-flex gap-2 flex-wrap">
                                    <div class="text-center p-2">
                                        <div class="spinner-border spinner-border-sm" role="status"></div>
                                        <small class="d-block">Loading...</small>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="row">
                            <!-- Import Section -->
                            <div class="col-md-6">
                                <div class="tennis-import-section">
                                    <h5 class="mb-3">
                                        <i class="fas fa-upload text-tennis-primary"></i> 
                                        Smart Import
                                    </h5>
                                    <p class="text-muted">Upload any YAML file containing leagues, facilities, teams, or matches.</p>
                                    
                                    <!-- File Upload Area -->
                                    <div class="tennis-file-upload-area border border-2 border-dashed rounded p-4 text-center mb-3" 
                                         id="fileUploadArea">
                                        <div class="tennis-file-upload-content">
                                            <i class="fas fa-cloud-upload-alt fa-3x text-tennis-primary mb-3"></i>
                                            <div>
                                                <strong>Drop YAML file here or click to browse</strong>
                                                <div class="small text-muted mt-1">Supports any combination of components</div>
                                            </div>
                                        </div>
                                        <input type="file" id="universalFileInput" accept=".yaml,.yml" style="display: none;">
                                        <button class="btn btn-tennis-primary mt-3" onclick="document.getElementById('universalFileInput').click()">
                                            <i class="fas fa-folder-open"></i> Select File
                                        </button>
                                    </div>

                                    <!-- File Analysis Preview -->
                                    <div id="fileAnalysis" class="d-none mb-3">
                                        <div class="alert alert-info">
                                            <div id="analysisContent"></div>
                                        </div>
                                    </div>
                                    
                                    <!-- Import Actions -->
                                    <div class="tennis-import-actions d-flex gap-2 mb-3">
                                        <button class="btn btn-tennis-success" id="importBtn" onclick="TennisImportExport.executeImport()" disabled>
                                            <i class="fas fa-upload"></i> Import Data
                                        </button>
                                        <button class="btn btn-outline-info" id="validateBtn" onclick="TennisImportExport.validateOnly()" disabled>
                                            <i class="fas fa-check-circle"></i> Validate Only
                                        </button>
                                        <button class="btn btn-outline-secondary" onclick="TennisImportExport.clearFile()" id="clearBtn" disabled>
                                            <i class="fas fa-times"></i> Clear
                                        </button>
                                    </div>

                                    <!-- Import Status -->
                                    <div id="importStatus" class="d-none">
                                        <div class="alert" role="alert">
                                            <div id="importMessage"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Export Section -->
                            <div class="col-md-6">
                                <div class="tennis-export-section">
                                    <h5 class="mb-3">
                                        <i class="fas fa-download text-tennis-success"></i> 
                                        Export Data
                                    </h5>
                                    <p class="text-muted">Download your data in YAML or JSON format.</p>
                                    
                                    <!-- Complete Database Export -->
                                    <div class="mb-4">
                                        <h6>Complete Database</h6>
                                        <div class="d-grid gap-2">
                                            <button class="btn btn-tennis-success" onclick="TennisImportExport.exportComplete('yaml')">
                                                <i class="fas fa-database"></i> Export All (YAML)
                                            </button>
                                            <button class="btn btn-tennis-info" onclick="TennisImportExport.exportComplete('json')">
                                                <i class="fas fa-file-export"></i> Export All (JSON)
                                            </button>
                                        </div>
                                    </div>

                                    <!-- Component Selection Export -->
                                    <div class="mb-4">
                                        <h6>Select Components</h6>
                                        <div id="componentSelection" class="mb-3">
                                            <div class="form-check">
                                                <input class="form-check-input" type="checkbox" value="leagues" id="exportLeagues">
                                                <label class="form-check-label" for="exportLeagues">
                                                    <i class="fas fa-trophy text-warning"></i> Leagues
                                                </label>
                                            </div>
                                            <div class="form-check">
                                                <input class="form-check-input" type="checkbox" value="facilities" id="exportFacilities">
                                                <label class="form-check-label" for="exportFacilities">
                                                    <i class="fas fa-building text-info"></i> Facilities
                                                </label>
                                            </div>
                                            <div class="form-check">
                                                <input class="form-check-input" type="checkbox" value="teams" id="exportTeams">
                                                <label class="form-check-label" for="exportTeams">
                                                    <i class="fas fa-users text-success"></i> Teams
                                                </label>
                                            </div>
                                            <div class="form-check">
                                                <input class="form-check-input" type="checkbox" value="matches" id="exportMatches">
                                                <label class="form-check-label" for="exportMatches">
                                                    <i class="fas fa-calendar text-primary"></i> Matches
                                                </label>
                                            </div>
                                        </div>
                                        <div class="d-grid gap-2">
                                            <button class="btn btn-outline-success" onclick="TennisImportExport.exportSelected('yaml')">
                                                <i class="fas fa-download"></i> Export Selected (YAML)
                                            </button>
                                            <button class="btn btn-outline-info" onclick="TennisImportExport.exportSelected('json')">
                                                <i class="fas fa-download"></i> Export Selected (JSON)
                                            </button>
                                        </div>
                                    </div>

                                    <!-- Example Files -->
                                    <div>
                                        <h6>Example Files</h6>
                                        <div class="d-grid gap-1">
                                            <button class="btn btn-outline-secondary btn-sm" onclick="TennisImportExport.downloadExample('complete')">
                                                <i class="fas fa-file-code"></i> Complete Example
                                            </button>
                                            <button class="btn btn-outline-secondary btn-sm" onclick="TennisImportExport.downloadExample('mixed')">
                                                <i class="fas fa-file-alt"></i> Mixed Components
                                            </button>
                                            <button class="btn btn-outline-secondary btn-sm" onclick="TennisImportExport.downloadExample('leagues')">
                                                <i class="fas fa-trophy"></i> Leagues Only
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                            <i class="fas fa-times"></i> Close
                        </button>
                        <button type="button" class="btn btn-tennis-primary" onclick="window.location.reload()" id="refreshBtn" style="display: none;">
                            <i class="fas fa-sync-alt"></i> Refresh Page
                        </button>
                    </div>
                </div>
            </div>
        </div>`;
    }

    /**
     * Setup event handlers for the modal
     */
    static setupEventHandlers() {
        const fileInput = document.getElementById('universalFileInput');
        const uploadArea = document.getElementById('fileUploadArea');

        if (fileInput && uploadArea) {
            // File input change handler
            fileInput.addEventListener('change', (e) => {
                this.handleFileSelection(e.target.files[0]);
            });

            // Drag and drop handlers
            uploadArea.addEventListener('click', () => {
                fileInput.click();
            });

            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('border-primary', 'bg-light');
            });

            uploadArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('border-primary', 'bg-light');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('border-primary', 'bg-light');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    this.handleFileSelection(files[0]);
                }
            });
        }
    }

    /**
     * Load current component information
     */
    static async loadComponentInfo() {
        try {
            const response = await fetch('/api/import-export/components');
            const result = await response.json();
            
            if (result.success) {
                this.displayComponentStatus(result.components, result.total_items);
            }
        } catch (error) {
            console.error('Error loading component info:', error);
        }
    }

    /**
     * Display current component status
     */
    static displayComponentStatus(components, totalItems) {
        const container = document.getElementById('componentStatus');
        if (!container) return;

        const badges = Object.entries(components).map(([key, info]) => {
            const count = info.current_count || 0;
            const colorClass = count > 0 ? info.color : 'secondary';
            
            return `
                <div class="text-center">
                    <span class="badge bg-${colorClass} d-block mb-1">
                        <i class="${info.icon}"></i> ${count}
                    </span>
                    <small class="d-block">${info.display_name}</small>
                </div>
            `;
        }).join('');

        container.innerHTML = `
            ${badges}
            <div class="text-center">
                <span class="badge bg-dark d-block mb-1">
                    <i class="fas fa-database"></i> ${totalItems}
                </span>
                <small class="d-block">Total</small>
            </div>
        `;
    }

    /**
     * Handle file selection and analysis
     */
    static async handleFileSelection(file) {
        if (!file) return;

        // Validate file type
        if (!file.name.toLowerCase().endsWith('.yaml') && !file.name.toLowerCase().endsWith('.yml')) {
            TennisUI.showNotification('Please select a YAML file (.yaml or .yml)', 'warning');
            return;
        }

        this.selectedFile = file;
        this.updateFileDisplay(file);

        // Analyze file content
        await this.analyzeFile(file);
    }

    /**
     * Analyze uploaded file
     */
    static async analyzeFile(file) {
        try {
            const formData = new FormData();
            formData.append('file', file);

            const response = await fetch('/api/import-export/analyze', {
                method: 'POST',
                body: formData
            });

            const result = await response.json();

            if (result.success) {
                this.fileAnalysis = result.analysis;
                this.displayAnalysis(result.analysis);
                this.enableImportButtons();
            } else {
                this.showAnalysisError(result.error);
            }
        } catch (error) {
            console.error('Analysis error:', error);
            this.showAnalysisError(`Network error: ${error.message}`);
        }
    }

    /**
     * Display file analysis results
     */
    static displayAnalysis(analysis) {
        const analysisDiv = document.getElementById('fileAnalysis');
        const contentDiv = document.getElementById('analysisContent');

        if (!analysisDiv || !contentDiv) return;

        if (analysis.is_valid) {
            const componentBadges = analysis.components_found.map(component => {
                const count = analysis.component_counts[component];
                const info = ComponentInfo?.COMPONENTS?.[component] || { display_name: component, color: 'secondary', icon: 'fas fa-cube' };
                return `<span class="badge bg-${info.color} me-1"><i class="${info.icon}"></i> ${count} ${info.display_name}</span>`;
            }).join('');

            contentDiv.innerHTML = `
                <h6><i class="fas fa-eye text-info"></i> File Analysis</h6>
                <p><strong>Components found:</strong></p>
                <div class="mb-2">${componentBadges}</div>
                <p class="small mb-0">Total: ${analysis.total_items} items ready for import</p>
            `;

            analysisDiv.className = 'alert alert-success';
        } else {
            contentDiv.innerHTML = `
                <h6><i class="fas fa-exclamation-triangle text-warning"></i> File Issues</h6>
                <p>${analysis.error || 'No valid components found in file'}</p>
            `;
            analysisDiv.className = 'alert alert-warning';
        }

        analysisDiv.classList.remove('d-none');
    }

    /**
     * Show analysis error
     */
    static showAnalysisError(error) {
        const analysisDiv = document.getElementById('fileAnalysis');
        const contentDiv = document.getElementById('analysisContent');

        if (analysisDiv && contentDiv) {
            contentDiv.innerHTML = `
                <h6><i class="fas fa-exclamation-circle text-danger"></i> Analysis Failed</h6>
                <p>${error}</p>
            `;
            analysisDiv.className = 'alert alert-danger';
            analysisDiv.classList.remove('d-none');
        }
    }

    /**
     * Update file display in upload area
     */
    static updateFileDisplay(file) {
        const uploadArea = document.getElementById('fileUploadArea');
        const fileSizeKB = (file.size / 1024).toFixed(1);
        
        uploadArea.innerHTML = `
            <div class="text-center">
                <i class="fas fa-file-code fa-2x text-success mb-2"></i>
                <div>
                    <strong>${file.name}</strong>
                    <div class="small text-muted">${fileSizeKB} KB • Ready for analysis</div>
                </div>
            </div>
        `;
    }

    /**
     * Enable import buttons
     */
    static enableImportButtons() {
        document.getElementById('importBtn').disabled = false;
        document.getElementById('validateBtn').disabled = false;
        document.getElementById('clearBtn').disabled = false;
    }

    /**
     * Clear selected file
     */
    static clearFile() {
        this.selectedFile = null;
        this.fileAnalysis = null;
        
        // Reset upload area
        const uploadArea = document.getElementById('fileUploadArea');
        uploadArea.innerHTML = `
            <div class="tennis-file-upload-content">
                <i class="fas fa-cloud-upload-alt fa-3x text-tennis-primary mb-3"></i>
                <div>
                    <strong>Drop YAML file here or click to browse</strong>
                    <div class="small text-muted mt-1">Supports any combination of components</div>
                </div>
            </div>
            <input type="file" id="universalFileInput" accept=".yaml,.yml" style="display: none;">
            <button class="btn btn-tennis-primary mt-3" onclick="document.getElementById('universalFileInput').click()">
                <i class="fas fa-folder-open"></i> Select File
            </button>
        `;

        // Re-setup event handlers
        setTimeout(() => this.setupEventHandlers(), 100);

        // Disable buttons
        document.getElementById('importBtn').disabled = true;
        document.getElementById('validateBtn').disabled = true;
        document.getElementById('clearBtn').disabled = true;

        // Hide analysis
        document.getElementById('fileAnalysis').classList.add('d-none');
        this.hideImportStatus();
    }

    /**
     * Execute import
     */
    static async executeImport() {
        await this.performImport(false);
    }

    /**
     * Validate only without importing
     */
    static async validateOnly() {
        await this.performImport(true);
    }

    /**
     * Perform import or validation
     */
    static async performImport(validateOnly = false) {
        if (!this.selectedFile) {
            TennisUI.showNotification('Please select a file first', 'warning');
            return;
        }

        try {
            const actionText = validateOnly ? 'Validating' : 'Importing';
            this.showImportStatus('info', `${actionText} file...`, true);
            TennisUI.setButtonLoading(validateOnly ? 'validateBtn' : 'importBtn', true, `${actionText}...`);

            const formData = new FormData();
            formData.append('file', this.selectedFile);
            formData.append('skip_existing', 'true');
            formData.append('validate_only', validateOnly.toString());

            const response = await fetch('/api/import-export/import', {
                method: 'POST',
                body: formData
            });

            const result = await response.json();

            if (result.success) {
                this.showImportSuccess(result, validateOnly);
                TennisUI.showNotification(`${actionText} completed successfully!`, 'success');
                
                if (!validateOnly) {
                    // Show refresh button
                    document.getElementById('refreshBtn').style.display = 'inline-block';
                    // Reload component info
                    this.loadComponentInfo();
                }
            } else {
                this.showImportError(result);
                TennisUI.showNotification(`${actionText} failed: ${result.error}`, 'danger');
            }

        } catch (error) {
            console.error('Import error:', error);
            this.showImportStatus('danger', `Network error: ${error.message}`, false);
            TennisUI.showNotification('Import failed: Network error', 'danger');
        } finally {
            TennisUI.setButtonLoading('importBtn', false);
            TennisUI.setButtonLoading('validateBtn', false);
        }
    }

    /**
     * Export complete database
     */
    static async exportComplete(format) {
        try {
            const url = `/api/import-export/export?format=${format}`;
            window.open(url, '_blank');
            TennisUI.showNotification(`Complete database export started (${format.toUpperCase()})`, 'success');
        } catch (error) {
            console.error('Export error:', error);
            TennisUI.showNotification('Export failed', 'danger');
        }
    }

    /**
     * Export selected components
     */
    static async exportSelected(format) {
        const checkboxes = document.querySelectorAll('#componentSelection input[type="checkbox"]:checked');
        const selectedComponents = Array.from(checkboxes).map(cb => cb.value);

        if (selectedComponents.length === 0) {
            TennisUI.showNotification('Please select at least one component to export', 'warning');
            return;
        }

        try {
            const params = new URLSearchParams();
            params.append('format', format);
            selectedComponents.forEach(component => params.append('components', component));
            
            const url = `/api/import-export/export?${params.toString()}`;
            window.open(url, '_blank');
            TennisUI.showNotification(`Selected components export started (${format.toUpperCase()})`, 'success');
        } catch (error) {
            console.error('Export error:', error);
            TennisUI.showNotification('Export failed', 'danger');
        }
    }

    /**
     * Download example file
     */
    static async downloadExample(type) {
        try {
            const url = `/api/import-export/examples/${type}`;
            window.open(url, '_blank');
            TennisUI.showNotification(`Example file download started`, 'success');
        } catch (error) {
            console.error('Download error:', error);
            TennisUI.showNotification('Download failed', 'danger');
        }
    }

    /**
     * Show import status
     */
    static showImportStatus(type, message, showSpinner = false) {
        const statusDiv = document.getElementById('importStatus');
        const messageDiv = document.getElementById('importMessage');

        if (statusDiv && messageDiv) {
            const alertClass = `alert-${type}`;
            statusDiv.className = `alert ${alertClass}`;
            
            const spinnerHtml = showSpinner ? '<div class="spinner-border spinner-border-sm me-2" role="status"></div>' : '';
            messageDiv.innerHTML = `${spinnerHtml}${message}`;
            
            statusDiv.classList.remove('d-none');
        }
    }

    /**
     * Hide import status
     */
    static hideImportStatus() {
        const statusDiv = document.getElementById('importStatus');
        if (statusDiv) {
            statusDiv.classList.add('d-none');
        }
    }

    /**
     * Show import success
     */
    static showImportSuccess(result, validateOnly) {
        const action = validateOnly ? 'Validation' : 'Import';
        const componentsProcessed = result.components_processed || [];
        
        let message = `<h6><i class="fas fa-check-circle text-success"></i> ${action} Successful</h6>`;
        
        if (componentsProcessed.length > 0) {
            message += `<p><strong>Components processed:</strong> ${componentsProcessed.join(', ')}</p>`;
        }
        
        if (result.summary) {
            message += `<p class="small">${result.summary}</p>`;
        }

        this.showImportStatus('success', message, false);
    }

    /**
     * Show import error
     */
    static showImportError(result) {
        const message = `
            <h6><i class="fas fa-exclamation-triangle text-danger"></i> Import Failed</h6>
            <p><strong>Error:</strong> ${result.error || 'Unknown error'}</p>
        `;
        this.showImportStatus('danger', message, false);
    }

    /**
     * Remove existing modal from DOM
     */
    static removeExistingModal() {
        const existingModal = document.getElementById('tennisUniversalModal');
        if (existingModal) {
            existingModal.remove();
        }
        this.currentModal = null;
        this.selectedFile = null;
        this.fileAnalysis = null;
    }
}

    

// ==================== GLOBAL Functions ====================

    
/**
 * Handle refresh button click in notifications
 */
function handleNotificationRefresh(button) {
    const notification = button.closest('.tennis-notification');
    if (notification && notification._refreshCallback) {
        // Show loading state on button
        const originalContent = button.innerHTML;
        button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Refreshing...';
        button.disabled = true;
        
        // Execute refresh callback
        try {
            notification._refreshCallback();
        } catch (error) {
            console.error('Refresh callback error:', error);
            // Restore button state on error
            button.innerHTML = originalContent;
            button.disabled = false;
        }
    }
}

// ==================== GLOBAL INITIALIZATION ====================

// Auto-initialize when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    TennisUI.init();
    TennisForms.initializeFormValidation();
    TennisDropdowns.init();
    TennisBadges.init();
    TennisCards.init();
});

// Make classes available globally - add TennisImportExport
window.TennisImportExport = TennisImportExport;

// Make classes available globally
window.TennisUI = TennisUI;
window.TennisLeagues = TennisLeagues;
window.TennisTeams = TennisTeams;
window.TennisMatches = TennisMatches;
window.TennisFacilities = TennisFacilities;
window.TennisForms = TennisForms;
window.TennisDropdowns = TennisDropdowns;
window.TennisBadges = TennisBadges;
window.TennisCards = TennisCards;
</script>
