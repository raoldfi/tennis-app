<script>
/**
 * Tennis App - Standardized JavaScript Functions
 * Version 1.0 - Complete UI Management System
 * 
 * This script provides a unified interface for all modal, form, and UI interactions
 * across the Tennis Database Web Application.
 */

class TennisUI {
    
    /**
     * Initialize the Tennis UI system
     */
    static init() {
        this.setupEventListeners();
        this.initializeTooltips();
        this.autoHideAlerts();
    }

    // ==================== MODAL MANAGEMENT ====================

    /**
     * Show a modal with standardized behavior
     * @param {string} modalId - The ID of the modal to show
     * @param {Object} options - Optional configuration
     * @returns {bootstrap.Modal} - The modal instance
     */
    static showModal(modalId, options = {}) {
        const modalElement = document.getElementById(modalId);
        if (!modalElement) {
            console.error(`Modal with ID '${modalId}' not found`);
            return null;
        }

        const modal = new bootstrap.Modal(modalElement, {
            backdrop: options.backdrop || 'static',
            keyboard: options.keyboard !== false,
            focus: options.focus !== false
        });
        
        modal.show();
        
        // Add event listeners for this modal instance
        modalElement.addEventListener('shown.bs.modal', () => {
            // Focus first input field when modal opens
            const firstInput = modalElement.querySelector('input:not([type="hidden"]), select, textarea');
            if (firstInput) {
                firstInput.focus();
            }
        });

        return modal;
    }

    /**
     * Hide a modal
     * @param {string} modalId - The ID of the modal to hide
     */
    static hideModal(modalId) {
        const modal = bootstrap.Modal.getInstance(document.getElementById(modalId));
        if (modal) {
            modal.hide();
        }
    }

    /**
     * Set modal content dynamically
     * @param {string} modalId - The ID of the modal
     * @param {string} contentElementId - The ID of the content container
     * @param {string} content - HTML content to set
     */
    static setModalContent(modalId, contentElementId, content) {
        const contentElement = document.querySelector(`#${modalId} #${contentElementId}`);
        if (contentElement) {
            contentElement.innerHTML = content;
        } else {
            console.warn(`Content element '${contentElementId}' not found in modal '${modalId}'`);
        }
    }

    /**
     * Set modal title
     * @param {string} modalId - The ID of the modal
     * @param {string} title - New title with icon (HTML allowed)
     */
    static setModalTitle(modalId, title) {
        const titleElement = document.querySelector(`#${modalId} .modal-title`);
        if (titleElement) {
            titleElement.innerHTML = title;
        }
    }

    /**
     * Get data from modal form
     * @param {string} modalId - The ID of the modal
     * @param {string} formId - The ID of the form (optional)
     * @returns {Object} - Form data as object
     */
    static getModalFormData(modalId, formId = null) {
        const modal = document.getElementById(modalId);
        const form = formId ? document.getElementById(formId) : modal.querySelector('form');
        
        if (!form) {
            console.warn(`No form found in modal '${modalId}'`);
            return {};
        }

        return this.serializeForm(form.id);
    }

    // ==================== FORM MANAGEMENT ====================

    /**
     * Set form loading state
     * @param {string} formId - The ID of the form
     * @param {boolean} loading - Whether form is loading
     * @param {string} buttonSelector - CSS selector for the submit button
     */
    static setFormLoading(formId, loading, buttonSelector = 'button[type="submit"], .btn-tennis-success, .btn-tennis-primary') {
        const form = document.getElementById(formId);
        if (!form) {
            console.error(`Form with ID '${formId}' not found`);
            return;
        }

        const button = form.querySelector(buttonSelector);
        
        if (loading) {
            form.classList.add('tennis-loading');
            
            // Create loading overlay
            let overlay = document.getElementById(`${formId}-loading`);
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.className = 'tennis-loading-overlay';
                overlay.innerHTML = '<div class="tennis-spinner"></div>';
                overlay.id = `${formId}-loading`;
                form.appendChild(overlay);
            }
            
            // Disable and update submit button
            if (button) {
                button.disabled = true;
                if (!button.dataset.originalText) {
                    button.dataset.originalText = button.innerHTML;
                }
                button.innerHTML = '<div class="tennis-spinner tennis-spinner-sm"></div>Processing...';
                button.classList.add('btn-loading');
            }

            // Disable all form inputs
            const inputs = form.querySelectorAll('input, select, textarea, button');
            inputs.forEach(input => {
                if (!input.hasAttribute('data-loading-disabled')) {
                    input.disabled = true;
                    input.setAttribute('data-loading-disabled', 'true');
                }
            });

        } else {
            form.classList.remove('tennis-loading');
            
            // Remove loading overlay
            const overlay = document.getElementById(`${formId}-loading`);
            if (overlay) {
                overlay.remove();
            }
            
            // Re-enable submit button
            if (button) {
                button.disabled = false;
                button.classList.remove('btn-loading');
                if (button.dataset.originalText) {
                    button.innerHTML = button.dataset.originalText;
                    delete button.dataset.originalText;
                }
            }

            // Re-enable form inputs
            const inputs = form.querySelectorAll('[data-loading-disabled]');
            inputs.forEach(input => {
                input.disabled = false;
                input.removeAttribute('data-loading-disabled');
            });
        }
    }

    /**
     * Set button loading state
     * @param {HTMLElement} button - The button element
     * @param {boolean} loading - Whether button is loading
     * @param {string} loadingText - Text to show when loading
     */
    static setButtonLoading(button, loading, loadingText = 'Loading...') {
        if (!button) return;

        if (loading) {
            button.disabled = true;
            if (!button.dataset.originalText) {
                button.dataset.originalText = button.innerHTML;
            }
            button.innerHTML = `<div class="tennis-spinner tennis-spinner-sm"></div>${loadingText}`;
            button.classList.add('btn-loading');
        } else {
            button.disabled = false;
            button.classList.remove('btn-loading');
            if (button.dataset.originalText) {
                button.innerHTML = button.dataset.originalText;
                delete button.dataset.originalText;
            }
        }
    }

    /**
     * Validate form fields
     * @param {string} formId - The ID of the form
     * @param {Object} options - Validation options
     * @returns {boolean} - True if form is valid
     */
    static validateForm(formId, options = {}) {
        const form = document.getElementById(formId);
        if (!form) {
            console.error(`Form with ID '${formId}' not found`);
            return false;
        }

        const showMessages = options.showMessages !== false;
        const requiredFields = form.querySelectorAll('[required]');
        let isValid = true;
        let firstInvalidField = null;

        // Clear previous validation states
        this.resetValidation(formId);

        requiredFields.forEach(field => {
            const value = field.type === 'checkbox' ? field.checked : field.value.trim();
            const isEmpty = field.type === 'checkbox' ? !value : !value;

            if (isEmpty) {
                isValid = false;
                if (!firstInvalidField) {
                    firstInvalidField = field;
                }

                if (showMessages) {
                    field.classList.add('is-invalid');
                    this.showFieldError(field, 'This field is required');
                }
            } else {
                if (showMessages) {
                    field.classList.add('is-valid');
                }
            }
        });

        // Email validation
        const emailFields = form.querySelectorAll('input[type="email"]');
        emailFields.forEach(field => {
            if (field.value && !this.isValidEmail(field.value)) {
                isValid = false;
                if (!firstInvalidField) {
                    firstInvalidField = field;
                }

                if (showMessages) {
                    field.classList.add('is-invalid');
                    this.showFieldError(field, 'Please enter a valid email address');
                }
            }
        });

        // Focus first invalid field
        if (!isValid && firstInvalidField) {
            firstInvalidField.focus();
        }

        return isValid;
    }

    /**
     * Setup form validation for all forms on the page
     */
    static setupFormValidation() {
        // Real-time validation setup
        document.addEventListener('input', (e) => {
            const field = e.target;
            if (field.hasAttribute('required') || field.type === 'email') {
                this.validateField(field);
            }
        });

        document.addEventListener('change', (e) => {
            const field = e.target;
            if (field.hasAttribute('required') || field.type === 'email') {
                this.validateField(field);
            }
        });
    }

    /**
     * Validate a single field
     * @param {HTMLElement} field - The field to validate
     */
    static validateField(field) {
        const value = field.type === 'checkbox' ? field.checked : field.value.trim();
        const isEmpty = field.type === 'checkbox' ? !value : !value;

        // Remove existing validation classes
        field.classList.remove('is-valid', 'is-invalid');
        this.removeFieldError(field);

        if (field.hasAttribute('required') && isEmpty) {
            field.classList.add('is-invalid');
            this.showFieldError(field, 'This field is required');
        } else if (field.type === 'email' && value && !this.isValidEmail(value)) {
            field.classList.add('is-invalid');
            this.showFieldError(field, 'Please enter a valid email address');
        } else if (!isEmpty) {
            field.classList.add('is-valid');
        }
    }

    /**
     * Reset validation state for a form
     * @param {string} formId - The ID of the form
     */
    static resetValidation(formId) {
        const form = document.getElementById(formId);
        if (!form) return;

        const fields = form.querySelectorAll('.is-valid, .is-invalid');
        fields.forEach(field => {
            field.classList.remove('is-valid', 'is-invalid');
            this.removeFieldError(field);
        });
    }

    /**
     * Show field error message
     * @param {HTMLElement} field - The field element
     * @param {string} message - Error message
     */
    static showFieldError(field, message) {
        this.removeFieldError(field);
        
        const errorDiv = document.createElement('div');
        errorDiv.className = 'invalid-feedback';
        errorDiv.textContent = message;
        errorDiv.setAttribute('data-field-error', field.id || field.name);
        
        field.parentNode.appendChild(errorDiv);
    }

    /**
     * Remove field error message
     * @param {HTMLElement} field - The field element
     */
    static removeFieldError(field) {
        const errorDiv = field.parentNode.querySelector(`[data-field-error="${field.id || field.name}"]`);
        if (errorDiv) {
            errorDiv.remove();
        }
    }

    /**
     * Serialize form data to object
     * @param {string} formId - The ID of the form
     * @returns {Object} - Form data as object
     */
    static serializeForm(formId) {
        const form = document.getElementById(formId);
        if (!form) return {};

        const formData = new FormData(form);
        const data = {};
        
        for (const [key, value] of formData.entries()) {
            data[key] = value;
        }
        
        return data;
    }

    // ==================== TABLE INTERACTIONS ====================

    /**
     * Setup table interactions for enhanced UX
     * @param {string} tableId - The ID of the table (optional)
     */
    static setupTableInteractions(tableId = null) {
        const tables = tableId ? [document.getElementById(tableId)] : document.querySelectorAll('.tennis-table');
        
        tables.forEach(table => {
            if (!table) return;
            
            // Add hover effects
            const rows = table.querySelectorAll('tbody tr');
            rows.forEach(row => {
                row.addEventListener('mouseenter', function() {
                    this.style.transform = 'translateX(2px)';
                    this.style.transition = 'transform 0.2s ease';
                });
                
                row.addEventListener('mouseleave', function() {
                    this.style.transform = 'translateX(0)';
                });
            });
            
            // Add sorting functionality if headers are clickable
            const headers = table.querySelectorAll('th[data-sort]');
            headers.forEach(header => {
                header.style.cursor = 'pointer';
                header.addEventListener('click', () => {
                    this.sortTable(table, header.dataset.sort);
                });
            });
        });
    }

    /**
     * Sort table by column
     * @param {HTMLElement} table - The table element
     * @param {string} column - Column identifier
     */
    static sortTable(table, column) {
        // Basic table sorting implementation
        console.log(`Sorting table by column: ${column}`);
        // Implementation would depend on specific requirements
    }

    // ==================== NOTIFICATION SYSTEM ====================

    /**
     * Show notification to user
     * @param {string} message - Notification message
     * @param {string} type - Notification type (success, danger, warning, info)
     * @param {number} duration - Auto-hide duration in ms (0 = no auto-hide)
     */
    static showNotification(message, type = 'info', duration = 5000) {
        // Remove existing notifications
        const existingNotifications = document.querySelectorAll('.tennis-notification');
        existingNotifications.forEach(notification => notification.remove());

        // Create notification element
        const notification = document.createElement('div');
        notification.className = `tennis-notification alert alert-${type} alert-dismissible`;
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            min-width: 300px;
            max-width: 500px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            animation: slideInRight 0.3s ease;
        `;

        // Get appropriate icon
        const icons = {
            success: 'fas fa-check-circle',
            danger: 'fas fa-exclamation-triangle',
            warning: 'fas fa-exclamation-circle',
            info: 'fas fa-info-circle'
        };

        notification.innerHTML = `
            <i class="${icons[type] || icons.info} me-2"></i>
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;

        // Add to page
        document.body.appendChild(notification);

        // Auto-hide if duration is specified
        if (duration > 0) {
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.classList.add('fade');
                    setTimeout(() => notification.remove(), 150);
                }
            }, duration);
        }

        // Add slide-in animation styles if not already present
        if (!document.getElementById('tennis-notification-styles')) {
            const styles = document.createElement('style');
            styles.id = 'tennis-notification-styles';
            styles.textContent = `
                @keyframes slideInRight {
                    from { transform: translateX(100%); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
            `;
            document.head.appendChild(styles);
        }
    }

    // ==================== API UTILITIES ====================

    /**
     * Make API calls with standardized error handling
     * @param {string} url - API endpoint
     * @param {Object} options - Fetch options
     * @returns {Promise} - Response data
     */
    static async apiCall(url, options = {}) {
        try {
            const defaultHeaders = {};
            
            // Only add Content-Type for JSON data
            if (options.body && typeof options.body === 'string') {
                defaultHeaders['Content-Type'] = 'application/json';
            }
            
            const response = await fetch(url, {
                headers: {
                    ...defaultHeaders,
                    ...options.headers
                },
                ...options
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();
            return data;
        } catch (error) {
            console.error('API call failed:', error);
            throw error;
        }
    }

    // ==================== BULK OPERATIONS ====================

    /**
     * Execute a bulk operation with standardized UI updates
     * @param {string} operation - Operation name (for logging)
     * @param {string} url - API endpoint
     * @param {FormData|Object} data - Data to send
     * @param {string} modalId - Modal to close on success
     * @param {Function} successCallback - Optional success callback
     */
    static async executeBulkOperation(operation, url, data, modalId, successCallback = null) {
        const submitBtn = document.querySelector(`#${modalId} .btn-tennis-warning, #${modalId} .btn-tennis-danger, #${modalId} .btn-tennis-success, #${modalId} .btn-primary`);
        
        // Set button loading state
        if (submitBtn) {
            this.setButtonLoading(submitBtn, true, 'Processing...');
        }

        try {
            const options = {
                method: 'POST'
            };

            // Handle different data types
            if (data instanceof FormData) {
                options.body = data;
            } else if (typeof data === 'object') {
                options.body = JSON.stringify(data);
                options.headers = { 'Content-Type': 'application/json' };
            } else {
                options.body = data;
            }

            const result = await this.apiCall(url, options);

            // Close modal
            this.hideModal(modalId);

            // Show success message
            this.showNotification(result.message || `${operation} completed successfully!`, 'success');

            // Execute callback or reload page
            if (successCallback) {
                successCallback(result);
            } else {
                setTimeout(() => location.reload(), 1500);
            }

        } catch (error) {
            this.showNotification(`${operation} failed: ${error.message}`, 'danger');
        } finally {
            // Reset button state
            if (submitBtn) {
                this.setButtonLoading(submitBtn, false);
            }
        }
    }

    // ==================== UTILITY FUNCTIONS ====================

    /**
     * Initialize tooltips for elements
     */
    static initializeTooltips() {
        const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
        tooltipTriggerList.map(function (tooltipTriggerEl) {
            return new bootstrap.Tooltip(tooltipTriggerEl);
        });
    }

    /**
     * Validate email format
     * @param {string} email - Email to validate
     * @returns {boolean} - True if valid
     */
    static isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }

    /**
     * Format date for display
     * @param {string|Date} date - Date to format
     * @param {Object} options - Formatting options
     * @returns {string} - Formatted date
     */
    static formatDate(date, options = {}) {
        const dateObj = typeof date === 'string' ? new Date(date) : date;
        const defaultOptions = {
            year: 'numeric',
            month: 'short',
            day: 'numeric'
        };
        return dateObj.toLocaleDateString('en-US', { ...defaultOptions, ...options });
    }

    /**
     * Debounce function calls
     * @param {Function} func - Function to debounce
     * @param {number} wait - Wait time in ms
     * @returns {Function} - Debounced function
     */
    static debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    /**
     * Setup global event listeners
     */
    static setupEventListeners() {
        // Form submission handling
        document.addEventListener('submit', (e) => {
            const form = e.target;
            if (form.classList.contains('tennis-form')) {
                if (!this.validateForm(form.id, { showMessages: true })) {
                    e.preventDefault();
                    this.showNotification('Please fill in all required fields correctly', 'warning');
                }
            }
        });
    }

    /**
     * Auto-hide alert messages
     */
    static autoHideAlerts() {
        const alerts = document.querySelectorAll('.alert:not([data-persistent]):not([style*="position: fixed"])');
        alerts.forEach(alert => {
            if (!alert.classList.contains('alert-tennis')) {
                setTimeout(() => {
                    if (alert.parentNode) {
                        alert.classList.remove('show');
                        setTimeout(() => alert.remove(), 150);
                    }
                }, 5000);
            }
        });
    }
}

// ==================== INITIALIZATION ====================

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    TennisUI.init();
    
    // Make TennisUI globally available
    window.TennisUI = TennisUI;
    
    console.log('Tennis UI system initialized successfully');
});

console.log('Tennis App shared scripts loaded successfully');
</script>
